<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>WebGL Video Test</title>
		<style>
			body {
				font-family: Arial, sans-serif;
				padding: 20px;
			}
			.container {
				display: flex;
				gap: 20px;
				flex-wrap: wrap;
			}
			.debug-panel {
				flex: 1;
				min-width: 300px;
				background: #f5f5f5;
				padding: 15px;
				border-radius: 8px;
			}
			.webgl-container {
				flex: 1;
				min-width: 300px;
			}
			canvas {
				border: 1px solid #ccc;
				max-width: 100%;
			}
			video {
				max-width: 100%;
				margin-bottom: 10px;
			}
			.error {
				color: red;
				background: #ffe6e6;
				padding: 10px;
				border-radius: 4px;
				margin: 10px 0;
			}
			.success {
				color: green;
				background: #e6ffe6;
				padding: 10px;
				border-radius: 4px;
				margin: 10px 0;
			}
			pre {
				background: #000;
				color: #0f0;
				padding: 10px;
				border-radius: 4px;
				overflow-x: auto;
				font-size: 12px;
			}
		</style>
	</head>
	<body>
		<h1>WebGL Video Compatibility Test</h1>
		<p>This page helps debug WebGL video texture issues between different browsers.</p>

		<div class="container">
			<div class="debug-panel">
				<h2>Debug Information</h2>
				<div id="debug-info"></div>
				<h3>Console Output</h3>
				<pre id="console-output"></pre>
			</div>

			<div class="webgl-container">
				<h2>WebGL Canvas</h2>
				<video id="test-video" controls crossorigin="anonymous" loop muted>
					<source
						src="https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4"
						type="video/mp4"
					/>
					<source src="https://www.w3schools.com/html/mov_bbb.mp4" type="video/mp4" />
					Your browser does not support the video tag.
				</video>
				<br />
				<canvas id="webgl-canvas" width="640" height="360"></canvas>
				<br />
				<button onclick="startTest()">Start WebGL Test</button>
				<button onclick="clearConsole()">Clear Console</button>
			</div>
		</div>

		<script>
			// Capture console output
			const consoleOutput = document.getElementById('console-output');
			const originalLog = console.log;
			const originalError = console.error;
			const originalWarn = console.warn;

			function addToConsole(type, args) {
				const timestamp = new Date().toLocaleTimeString();
				const message = Array.from(args)
					.map((arg) =>
						typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
					)
					.join(' ');
				consoleOutput.textContent += `[${timestamp}] ${type.toUpperCase()}: ${message}\n`;
				consoleOutput.scrollTop = consoleOutput.scrollHeight;
			}

			console.log = (...args) => {
				originalLog.apply(console, args);
				addToConsole('log', args);
			};

			console.error = (...args) => {
				originalError.apply(console, args);
				addToConsole('error', args);
			};

			console.warn = (...args) => {
				originalWarn.apply(console, args);
				addToConsole('warn', args);
			};

			function clearConsole() {
				consoleOutput.textContent = '';
			}

			function displayDebugInfo() {
				const debugInfo = document.getElementById('debug-info');
				let html = '';

				// Browser info
				html += `<div class="success"><strong>Browser:</strong> ${navigator.userAgent}</div>`;
				html += `<div><strong>Platform:</strong> ${navigator.platform}</div>`;

				// WebGL support check
				const canvas = document.createElement('canvas');
				const webgl2 = canvas.getContext('webgl2');
				const webgl1 = canvas.getContext('webgl');

				if (webgl2) {
					html += `<div class="success">✓ WebGL2 supported</div>`;
				} else if (webgl1) {
					html += `<div class="success">✓ WebGL1 supported (WebGL2 not available)</div>`;
				} else {
					html += `<div class="error">✗ WebGL not supported</div>`;
					debugInfo.innerHTML = html;
					return;
				}

				const gl = webgl2 || webgl1;
				html += `<div><strong>Vendor:</strong> ${gl.getParameter(gl.VENDOR)}</div>`;
				html += `<div><strong>Renderer:</strong> ${gl.getParameter(gl.RENDERER)}</div>`;
				html += `<div><strong>Version:</strong> ${gl.getParameter(gl.VERSION)}</div>`;
				html += `<div><strong>Shading Language:</strong> ${gl.getParameter(
					gl.SHADING_LANGUAGE_VERSION
				)}</div>`;
				html += `<div><strong>Max Texture Size:</strong> ${gl.getParameter(
					gl.MAX_TEXTURE_SIZE
				)}</div>`;

				// Check extensions
				const extensions = gl.getSupportedExtensions();
				const importantExtensions = [
					'OES_texture_float',
					'OES_texture_float_linear',
					'WEBGL_lose_context',
					'EXT_texture_filter_anisotropic',
				];

				html += '<div><strong>Important Extensions:</strong><ul>';
				importantExtensions.forEach((ext) => {
					const supported = extensions.includes(ext);
					html += `<li style="color: ${supported ? 'green' : 'red'}">${ext}: ${
						supported ? '✓' : '✗'
					}</li>`;
				});
				html += '</ul></div>';

				debugInfo.innerHTML = html;
			}

			// Simple WebGL test
			function startTest() {
				console.log('Starting WebGL video texture test...');

				const canvas = document.getElementById('webgl-canvas');
				const video = document.getElementById('test-video');

				// Try to get WebGL context
				const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
				if (!gl) {
					console.error('Failed to get WebGL context');
					return;
				}

				console.log('WebGL context obtained successfully');

				// Simple vertex shader
				const vertexShaderSource =
					gl instanceof WebGL2RenderingContext
						? `#version 300 es
			             in vec2 a_position;
			             in vec2 a_texCoord;
			             out vec2 v_texCoord;
			             void main() {
			                 gl_Position = vec4(a_position, 0.0, 1.0);
			                 v_texCoord = a_texCoord;
			             }`
						: `attribute vec2 a_position;
			             attribute vec2 a_texCoord;
			             varying vec2 v_texCoord;
			             void main() {
			                 gl_Position = vec4(a_position, 0.0, 1.0);
			                 v_texCoord = a_texCoord;
			             }`;

				// Simple fragment shader
				const fragmentShaderSource =
					gl instanceof WebGL2RenderingContext
						? `#version 300 es
			             precision mediump float;
			             uniform sampler2D u_texture;
			             in vec2 v_texCoord;
			             out vec4 outColor;
			             void main() {
			                 outColor = texture(u_texture, v_texCoord);
			             }`
						: `precision mediump float;
			             uniform sampler2D u_texture;
			             varying vec2 v_texCoord;
			             void main() {
			                 gl_FragColor = texture2D(u_texture, v_texCoord);
			             }`;

				// Compile shader
				function compileShader(source, type) {
					const shader = gl.createShader(type);
					gl.shaderSource(shader, source);
					gl.compileShader(shader);

					if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
						const error = gl.getShaderInfoLog(shader);
						console.error('Shader compilation error:', error);
						gl.deleteShader(shader);
						return null;
					}
					return shader;
				}

				const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
				const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

				if (!vertexShader || !fragmentShader) {
					console.error('Shader compilation failed');
					return;
				}

				// Create program
				const program = gl.createProgram();
				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);
				gl.linkProgram(program);

				if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
					console.error('Program linking error:', gl.getProgramInfoLog(program));
					return;
				}

				console.log('Shaders compiled and linked successfully');

				// Set up geometry
				const positions = new Float32Array([
					-1, -1, 0, 1, 1, -1, 1, 1, -1, 1, 0, 0, -1, 1, 0, 0, 1, -1, 1, 1, 1, 1, 1, 0,
				]);

				const buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
				gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

				// Set up attributes
				const positionLocation = gl.getAttribLocation(program, 'a_position');
				const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');

				gl.enableVertexAttribArray(positionLocation);
				gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 16, 0);

				gl.enableVertexAttribArray(texCoordLocation);
				gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 16, 8);

				// Create texture
				const texture = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

				console.log('WebGL setup complete, starting render loop...');

				// Render function
				function render() {
					requestAnimationFrame(render);
					if (video.readyState < 2) return;
					gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);

					gl.viewport(0, 0, canvas.width, canvas.height);
					gl.clearColor(0, 0, 0, 1);
					gl.clear(gl.COLOR_BUFFER_BIT);

					gl.useProgram(program);
					gl.drawArrays(gl.TRIANGLES, 0, 6);

					// Check for errors
					const error = gl.getError();
					if (error !== gl.NO_ERROR) {
						console.error('WebGL error:', error);
					}
				}

				// Wait for video to be ready
				if (video.readyState >= 2) {
					console.log('Video already ready, starting render');
					render();
				} else {
					console.log('Waiting for video to be ready...');
					video.addEventListener(
						'canplay',
						() => {
							console.log('Video ready, starting render');
							render();
						},
						{ once: true }
					);

					video.play().catch((e) => {
						console.error('Video play failed:', e);
					});
				}
			}

			// Initialize on load
			window.addEventListener('load', () => {
				displayDebugInfo();
				console.log('Page loaded, ready for testing');
			});
		</script>
	</body>
</html>
